{"title":"ES6中的const命令","slug":"ES6中的const命令","date":"2018-05-31T08:20:38.000Z","updated":"2019-03-13T04:03:51.500Z","comments":true,"excerpt":"","content":"<p>在ES5中有两种声明变量的方法分别是var命令和function命令。在ES6中声明变量的方法扩展为了6种，还有let、const、import、class命令。在这里说一下const命令。</p>\n<h1 id=\"const的基本用法\"><a href=\"#const的基本用法\" class=\"headerlink\" title=\"const的基本用法\"></a>const的基本用法</h1><p>const命令声明一个只读常量，常量的值不可以改变。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const x = 2018;</span><br><span class=\"line\">x = 2019;       // Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure></p>\n<p>可以看出来，在const声明的常量值不可以改变。这也就意味着const一旦声明常量，就要立即初始化常量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const x;        // Uncaught SyntaxError: Missing initializer in const declaration</span><br></pre></td></tr></table></figure>\n<p>由此看出声明const常量时必须赋值。</p>\n<h1 id=\"与let有一样的特征\"><a href=\"#与let有一样的特征\" class=\"headerlink\" title=\"与let有一样的特征\"></a>与let有一样的特征</h1><h2 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h2><p>与let命令一样，const也存在暂时性死区，只能在声明后使用它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(x);     // Uncaught ReferenceError: x is not defined</span><br><span class=\"line\">const x = 5;</span><br></pre></td></tr></table></figure>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>还是与let命令一样，const命令只在声明它的块级作用域内有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    const x = 2018;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(x);     // Uncaught ReferenceError: x is not defined</span><br></pre></td></tr></table></figure>\n<h2 id=\"不可重复声明\"><a href=\"#不可重复声明\" class=\"headerlink\" title=\"不可重复声明\"></a>不可重复声明</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const x = 2018;</span><br><span class=\"line\">const y = 2019;</span><br><span class=\"line\">const x = 2010;         // Uncaught SyntaxError: Identifier &apos;x&apos; has already been declared</span><br><span class=\"line\">const y = 2011;         // Uncaught SyntaxError: Identifier &apos;y&apos; has already been declared</span><br></pre></td></tr></table></figure>\n<h1 id=\"const命令的本质\"><a href=\"#const命令的本质\" class=\"headerlink\" title=\"const命令的本质\"></a>const命令的本质</h1><p>const本质是变量值不可改变吗？并不是，学过C语言的都知道常量值是保存在地址中的，那么const的常量值不可改变，是指指向常量的那个内存地址不得改动。在js中分为简单数据类型和复合数据类型。对于简单数据类型，值就保存在变量指向的内存地址中。而对于复合数据类型，变量指向的是指向数据结构的指针，const只能保证这个指针不会发生改变，但是指针的另一头：指向的数据结构，就不能保证它不会发生变化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const x =&#123;&#125;;</span><br><span class=\"line\">x.int = 2018;</span><br><span class=\"line\">x.char = &apos;change&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(x.int);         // 2018</span><br><span class=\"line\"></span><br><span class=\"line\">x.int = 2015;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(x.int);         // 2015</span><br><span class=\"line\">console.log(x.char);        // change</span><br></pre></td></tr></table></figure>\n<p>以上代码我们改变了对象属性(指针所指向的数据结构)，x指向的对象还是发生了改变。</p>\n<h1 id=\"Object-freeze\"><a href=\"#Object-freeze\" class=\"headerlink\" title=\"Object.freeze\"></a>Object.freeze</h1><p>如果我们想让const指向的对象也不能改变怎么办，那么我们就需要Object.freeze方法了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const x = Object.freeze(&#123;&#125;);</span><br><span class=\"line\">x.int = 2018;               // 严格模式下会报错</span><br><span class=\"line\">console.log(x.int);         // undefined</span><br></pre></td></tr></table></figure>\n<p>在我们冻结了对象之后对象就完全冻结了吗？NO，如果对象的属性还是一个对象呢，它的值能不能改变？所以，我们还需要冻结对象的属性。</p>\n<p>以下函数可以彻底冻结一个对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var constantize = (obj) =&gt; &#123;</span><br><span class=\"line\">    Object.freeze(obj);</span><br><span class=\"line\">    Object.keys(obj).forEach( (key, i) =&gt; &#123;</span><br><span class=\"line\">        if( typeof obj[key] === &apos;object&apos;)&#123;</span><br><span class=\"line\">            constantize(obj[key]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","thumbnail":"http://poadan2tz.bkt.clouddn.com/44873217_p0.jpg","categories":[],"tags":[{"name":"ES6","path":"api/tags/ES6.json"}]}