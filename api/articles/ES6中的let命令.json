{"title":"ES6中的let命令","slug":"ES6中的let命令","date":"2018-05-30T09:41:04.000Z","updated":"2019-03-13T04:04:04.579Z","comments":true,"excerpt":"","content":"<p>ES6中新规定了let命令，用于声明变量，但是有了var命令，我们为什么还需要let命令呢。</p>\n<p>let用于声明变量，类似于var，但是用let声明的变量只在声明let的代码块内有效。</p>\n<h1 id=\"var和let的作用域区别\"><a href=\"#var和let的作用域区别\" class=\"headerlink\" title=\"var和let的作用域区别\"></a>var和let的作用域区别</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    var x = 2018;</span><br><span class=\"line\">    let y = 2019;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(x)       // 2018</span><br><span class=\"line\">console.log(y)       // Uncaught ReferenceError: y is not defined</span><br></pre></td></tr></table></figure>\n<p>还有js经典的循环问题<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[];</span><br><span class=\"line\">for(var i=0;i&lt;10;i++)&#123;</span><br><span class=\"line\">\ta[i]=function()&#123;</span><br><span class=\"line\">        console.log(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a[2]());        // 10</span><br></pre></td></tr></table></figure></p>\n<p>上面是用var声明i变量，在全局范围内有效，其中console.log(i)指向的是全局变量的i，也就是10次循环之后的值，也就是10.如果是用let声明i呢。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a=[];</span><br><span class=\"line\">for(let i=0;i&lt;10;i++)&#123;</span><br><span class=\"line\">    a[i]=function()&#123;</span><br><span class=\"line\">        console.log(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(a[2]());        // 2</span><br></pre></td></tr></table></figure></p>\n<p>这里的i用let声明，也就是i只在当前循环有效，每一次循环的i都是新的变量，所以可以准确的把每次i的值赋值给对应的数组元素。</p>\n<p>在这里要说明for循环处是一个父作用域，而循环内是一个单独的子作用域。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(let i=0;i&lt;3;i++)&#123;</span><br><span class=\"line\">    let i = &quot;children&quot;;</span><br><span class=\"line\">    console.log(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// children</span><br><span class=\"line\">// children</span><br><span class=\"line\">// children</span><br></pre></td></tr></table></figure></p>\n<p>这里的控制循环中的i不会受内部i的影响，说明在各自的作用域内。</p>\n<h1 id=\"变量提升？\"><a href=\"#变量提升？\" class=\"headerlink\" title=\"变量提升？\"></a>变量提升？</h1><p>js中变量的一大特点就是变量提升了，var会变量提升，那么let呢？</p>\n<h2 id=\"什么是变量提升\"><a href=\"#什么是变量提升\" class=\"headerlink\" title=\"什么是变量提升\"></a>什么是变量提升</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(x);         // undefined</span><br><span class=\"line\">var x = 2018;</span><br></pre></td></tr></table></figure>\n<p>在一般的程序中，我们会认为以上代码会报错Uncaught ReferenceError: x is not defined。因为在声明x之前就调用了x。但是js中会显示undefined，这就是变量提升了，在默认把所用变量的声明提升到程序顶部，类似于一下代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x;</span><br><span class=\"line\">console.log(x);         // undefined</span><br><span class=\"line\">x = 2018;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，在变量提升时。只会提升变量的声明，不会提升赋值，这也就是为什么输出是undefined，而不是2018。</p>\n<h2 id=\"let木有变量提升\"><a href=\"#let木有变量提升\" class=\"headerlink\" title=\"let木有变量提升\"></a>let木有变量提升</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(x);         // Uncaught ReferenceError: x is not defined</span><br><span class=\"line\">let x = 2018;</span><br></pre></td></tr></table></figure>\n<h1 id=\"暂时性死区（TDZ）\"><a href=\"#暂时性死区（TDZ）\" class=\"headerlink\" title=\"暂时性死区（TDZ）\"></a>暂时性死区（TDZ）</h1><p>暂时性死区就是在代码块内，使用let命令声明变量之前，该变量是不可用的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x = 2018;</span><br><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    x = 2019;       // Uncaught ReferenceError: x is not defined</span><br><span class=\"line\">    let x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只要在块级作用域中存在let命令，那么let声明的变量会绑定当前作用域，不受外部影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    //开始暂时性死区</span><br><span class=\"line\">    x = &apos;begin&apos;;        //Uncaught ReferenceError: x is not defined</span><br><span class=\"line\">    console.log(x);     //Uncaught ReferenceError: x is not defined</span><br><span class=\"line\"></span><br><span class=\"line\">    let x;      //暂时性死区结束</span><br><span class=\"line\">    console.log(x);     //undefined</span><br><span class=\"line\"></span><br><span class=\"line\">    x = &apos;end&apos;;</span><br><span class=\"line\">    console.log(x);     // end</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上方代码演示了暂时性死区的范围。<br>有一些暂时性死区是很隐蔽的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fun (x = y , y = 2)&#123;</span><br><span class=\"line\">    return [x,y]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun();      //Uncaught ReferenceError: y is not defined</span><br></pre></td></tr></table></figure></p>\n<p>这里的fun函数中，先是执行x=y语句，由于之后才进行y=2的声明，所以在y=2声明之前会暂时性死区。<br>如果改成以下这个样子，那么这个函数就没有问题了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fun (x = 2 , y = x)&#123;</span><br><span class=\"line\">    return [x,y]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun();      // [2,2]</span><br></pre></td></tr></table></figure></p>\n<p>总之，暂时性死区的本质就是，只要进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>\n<h1 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h1><p>let不允许在相同作用域中重复声明同一个变量，哪怕不用let命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fun () &#123;</span><br><span class=\"line\">    let x = 10;</span><br><span class=\"line\">    var x = 11;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun();      //报错</span><br></pre></td></tr></table></figure>\n<p>同理，函数内部也不能声明和参数一样的变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fun (x) &#123;</span><br><span class=\"line\">    let x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun();      //报错</span><br></pre></td></tr></table></figure></p>\n<p>这就是ES6中一些let命令的介绍。</p>\n","thumbnail":"http://poadan2tz.bkt.clouddn.com/37386131_p0.jpg","categories":[],"tags":[{"name":"ES6","path":"api/tags/ES6.json"}]}